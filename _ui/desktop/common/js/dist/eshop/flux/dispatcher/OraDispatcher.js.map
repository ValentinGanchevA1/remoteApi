{
    "version": 3,
    "sources": ["../../../../../es6/eshop/flux/dispatcher/OraDispatcher.js"],
    "names": ["OraDispatcher", "_prefix", "_callbacks", "_isDispatching", "_isHandled", "_isPending", "_pending", "_lastID", "register", "callback", "id", "unregister", "console", "assert", "waitFor", "ids", "ii", "length", "_invokeCallback", "dispatch", "payload", "log", "type", "_startDispatching", "_stopDispatching", "isDispatching", "e", "stack"],
    "mappings": ";;;;;;;;AAAA,MAAIA,aAAa,GAAG,UAAUA,aAAV,EAAyB;AAEzC,QAAIC,OAAO,GAAG,KAAd;AACA,QAAIC,UAAU,GAAG,EAAjB;AACA,QAAIC,cAAc,GAAG,KAArB;AACA,QAAIC,UAAU,GAAG,EAAjB;AACA,QAAIC,UAAU,GAAG,EAAjB;AACA,QAAIC,QAAQ,GAAG,EAAf;AACA,QAAIC,OAAO,GAAG,CAAd;AAEA;;;;;AAIAP,IAAAA,aAAa,CAACQ,QAAd,GAAyB,UAAUC,QAAV,EAAoB;AACzC,UAAIC,EAAE,GAAGT,OAAO,GAAGM,OAAO,EAA1B;AACAL,MAAAA,UAAU,CAACQ,EAAD,CAAV,GAAiBD,QAAjB;AACA,aAAOC,EAAP;AACH,KAJD;AAMA;;;;;AAGAV,IAAAA,aAAa,CAACW,UAAd,GAA2B,UAAUD,EAAV,EAAc;AACrCE,MAAAA,OAAO,CAACC,MAAR,CAAe,CAAC,CAACX,UAAU,CAACQ,EAAD,CAA3B,EAAiC,2DAAjC,EAA8FA,EAA9F;AACA,aAAOR,UAAU,CAACQ,EAAD,CAAjB;AACH,KAHD;AAKA;;;;;;;AAKAV,IAAAA,aAAa,CAACc,OAAd,GAAwB,UAAUC,GAAV,EAAe;AACnCH,MAAAA,OAAO,CAACC,MAAR,CAAeV,cAAf,EAA+B,oDAA/B;;AACA,WAAK,IAAIa,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGD,GAAG,CAACE,MAA1B,EAAkCD,EAAE,EAApC,EAAwC;AACpC,YAAIN,EAAE,GAAGK,GAAG,CAACC,EAAD,CAAZ;;AACA,YAAIX,UAAU,CAACK,EAAD,CAAd,EAAoB;AAChBE,UAAAA,OAAO,CAACC,MAAR,CAAeT,UAAU,CAACM,EAAD,CAAzB,EAA+B,2DAA/B,EAA4FA,EAA5F;AACA;AACH;;AACDE,QAAAA,OAAO,CAACC,MAAR,CAAe,CAAC,CAACX,UAAU,CAACQ,EAAD,CAA3B,EAAiC,wDAAjC,EAA2FA,EAA3F;;AACAQ,QAAAA,eAAe,CAACR,EAAD,CAAf;AACH;AACJ,KAXD;AAaA;;;;;AAGAV,IAAAA,aAAa,CAACmB,QAAd,GAAyB,UAAUC,OAAV,EAAmB;AACxCR,MAAAA,OAAO,CAACS,GAAR,8BAAkCD,OAAO,CAACE,IAA1C,iBAA4DF,OAA5D;AACAR,MAAAA,OAAO,CAACC,MAAR,CAAe,CAACV,cAAhB,EAAgC,gCAAhC,EAAkEA,cAAc,GAAGG,QAAQ,CAACc,OAAT,CAAiBE,IAApB,GAA2B,IAA3G;;AACAC,MAAAA,iBAAiB,CAACH,OAAD,CAAjB;;AACA,UAAI;AACA,aAAK,IAAIV,EAAT,IAAeR,UAAf,EAA2B;AACvC;AAEgB,cAAIG,UAAU,CAACK,EAAD,CAAd,EAAoB;AACnC;AACmB;AACH,WANsB,CAOvC;;;AACgBQ,UAAAA,eAAe,CAACR,EAAD,CAAf;AACH;AACJ,OAXD,SAWU;AACLE,QAAAA,OAAO,CAACS,GAAR,mCAAuCD,OAAO,CAACE,IAA/C,iBAAiEF,OAAjE;;AACDI,QAAAA,gBAAgB;AACnB;AACJ,KAnBD;AAqBA;;;;;AAGAxB,IAAAA,aAAa,CAACyB,aAAd,GAA8B,YAAY;AACtC,aAAOtB,cAAP;AACH,KAFD;AAIA;;;;;;AAIA,aAASe,eAAT,CAAyBR,EAAzB,EAA6B;AACzBL,MAAAA,UAAU,CAACK,EAAD,CAAV,GAAiB,IAAjB;;AACA,UAAI;AACAR,QAAAA,UAAU,CAACQ,EAAD,CAAV,CAAeJ,QAAQ,CAACc,OAAxB;AACH,OAFD,CAEE,OAAOM,CAAP,EAAU;AACRd,QAAAA,OAAO,CAACS,GAAR,sDAA0DK,CAA1D,gBAAiEA,CAAC,CAACC,KAAnE;AACH;;AACDvB,MAAAA,UAAU,CAACM,EAAD,CAAV,GAAiB,IAAjB;AACH;AAED;;;;;AAGA,aAASa,iBAAT,CAA2BH,OAA3B,EAAoC;AAChC,WAAK,IAAIV,EAAT,IAAeR,UAAf,EAA2B;AACvBG,QAAAA,UAAU,CAACK,EAAD,CAAV,GAAiB,KAAjB;AACAN,QAAAA,UAAU,CAACM,EAAD,CAAV,GAAiB,KAAjB;AACH;;AACDJ,MAAAA,QAAQ,CAACc,OAAT,GAAmBA,OAAnB;AACAjB,MAAAA,cAAc,GAAG,IAAjB;AACH;AAED;;;;;AAGA,aAASqB,gBAAT,GAA4B;AACxB,aAAOlB,QAAQ,CAACc,OAAhB;AACAjB,MAAAA,cAAc,GAAG,KAAjB;AACH;;AAED,WAAOH,aAAP;AACH,GAhHmB,CAgHlB,EAhHkB,CAApB;;iBAkHeA,a",
    "sourcesContent": ["var OraDispatcher = function (OraDispatcher) {\n\n    var _prefix = \"ID_\";\n    var _callbacks = {};\n    var _isDispatching = false;\n    var _isHandled = {};\n    var _isPending = {};\n    var _pending = {};\n    var _lastID = 1;\n\n    /**\n     * Registers a callback to be invoked with every dispatched payload. Returns\n     * a token that can be used with `waitFor()`.\n     */\n    OraDispatcher.register = function (callback) {\n        var id = _prefix + _lastID++;\n        _callbacks[id] = callback;\n        return id;\n    };\n\n    /**\n     * Removes a callback based on its token.\n     */\n    OraDispatcher.unregister = function (id) {\n        console.assert(!!_callbacks[id], \"Dispatcher.unregister: No store registered under id `%s`.\", id);\n        delete _callbacks[id];\n    };\n\n    /**\n     * Waits for the callbacks specified to be invoked before continuing execution\n     * of the current callback. This method should only be used by a callback in\n     * response to a dispatched payload.\n     */\n    OraDispatcher.waitFor = function (ids) {\n        console.assert(_isDispatching, \"Dispatcher.waitFor: invoked while not dispatching.\");\n        for (var ii = 0; ii < ids.length; ii++) {\n            var id = ids[ii];\n            if (_isPending[id]) {\n                console.assert(_isHandled[id], \"Dispatcher.waitFor: Circular dependency waiting for `%s`.\", id);\n                continue;\n            }\n            console.assert(!!_callbacks[id], \"Dispatcher.waitFor: No store registered under id `%s`.\", id);\n            _invokeCallback(id);\n        }\n    };\n\n    /**\n     * Dispatches a payload to all registered callbacks.\n     */\n    OraDispatcher.dispatch = function (payload) {\n        console.log(`Dispatching action ${payload.type}. Payload:`, payload);\n        console.assert(!_isDispatching, \"Already dispatching action %s.\", _isDispatching ? _pending.payload.type : null);\n        _startDispatching(payload);\n        try {\n            for (var id in _callbacks) {\n//                console.log(`Action processed: id:${id}`, id);\n\n                if (_isPending[id]) {\n //               console.log(`Action: id:${id}, is pending.`, id);\n                    continue;\n                }\n//                console.log(`Action: id:${id}, is not  pending.`, id);\n                _invokeCallback(id);\n            }\n        } finally {\n             console.log(`Stop dispatching action ${payload.type}. Payload:`, payload);\n            _stopDispatching();\n        }\n    };\n\n    /**\n     * Is Dispatcher currently dispatching.\n     */\n    OraDispatcher.isDispatching = function () {\n        return _isDispatching;\n    };\n\n    /**\n     * Call the callback stored with the given id. Also do some internal\n     * bookkeeping.\n     */\n    function _invokeCallback(id) {\n        _isPending[id] = true;\n        try {\n            _callbacks[id](_pending.payload);\n        } catch (e) {\n            console.log(`Error while invoking store action handler: ${e}\\n ${e.stack}`);\n        }\n        _isHandled[id] = true;\n    }\n\n    /**\n     * Set up bookkeeping needed when dispatching.\n     */\n    function _startDispatching(payload) {\n        for (var id in _callbacks) {\n            _isPending[id] = false;\n            _isHandled[id] = false;\n        }\n        _pending.payload = payload;\n        _isDispatching = true;\n    }\n\n    /**\n     * Clear bookkeeping used for dispatching.\n     */\n    function _stopDispatching() {\n        delete _pending.payload;\n        _isDispatching = false;\n    }\n\n    return OraDispatcher;\n}({});\n\nexport default OraDispatcher;\n"],
    "file": "OraDispatcher.js"
}